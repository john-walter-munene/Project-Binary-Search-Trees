/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n// Object Oriented approach to build a balanaced Binary Search Tree.\r\n\r\nclass Node {\r\n    constructor(data){\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\r\n\r\nclass Tree {\r\n    constructor(array) {\r\n        this.array = this.mergeSort(this.removeDuplicate(array));\r\n        this.root = this.buildTree(this.array);\r\n    }\r\n\r\n    removeDuplicate(array) {\r\n        // Exit if this is not an array.\r\n        if (!Array.isArray(array)) return;\r\n        return [...new Set(array)];\r\n    }\r\n\r\n    mergeSort(array, low = 0, high = array.length - 1) {\r\n        if (low < high) {\r\n\r\n            // Find middle point.\r\n            let middle = Math.floor((low + high) / 2);\r\n    \r\n            // Recursive sort both halves.\r\n            this.mergeSort(array, low, middle);\r\n            this.mergeSort(array, middle + 1, high);\r\n    \r\n            // Create copies of the subarrays\r\n            let leftArray = array.slice(low, middle + 1);\r\n            let rightArray = array.slice(middle + 1, high + 1);\r\n    \r\n            // Merge the arrays\r\n            let i = 0, j = 0, k = low;\r\n            while (i < leftArray.length && j < rightArray.length) {\r\n                if (leftArray[i] <= rightArray[j]) {\r\n                    array[k++] = leftArray[i++];\r\n                } else {\r\n                    array[k++] = rightArray[j++];\r\n                }\r\n            }\r\n    \r\n            // Copy remaining elements of leftArray, if any\r\n            while (i < leftArray.length) {\r\n                array[k++] = leftArray[i++];\r\n            }\r\n    \r\n             // Copy remaining elements of rightArray, if any\r\n            while (j < rightArray.length) {\r\n                array[k++] = rightArray[j++];\r\n            }\r\n        }\r\n    \r\n        return array;\r\n    }\r\n\r\n    buildTree(array, start = 0, end = array.length - 1) {\r\n        if (start > end) return null;\r\n\r\n        // Find middle element.\r\n        let mid = start + Math.floor((end - start) / 2);\r\n\r\n        // Create root node\r\n        let root = new Node(array[mid]);\r\n\r\n        // Create left and right subtrees.\r\n        root.left = this.buildTree(array, start, mid - 1);\r\n        root.right = this.buildTree(array, mid + 1, end);\r\n\r\n        return root;\r\n    }\r\n\r\n    insert(nodeData, currentNode = this.root) {\r\n        // If the tree is empty, initialize root with a new node.\r\n        if (this.root === null) {\r\n            this.root = new Node(nodeData);\r\n            return this.root;\r\n        }\r\n    \r\n        // If currentNode is null, return a new node (should not happen in typical usage).\r\n        if (currentNode === null) {\r\n            return new Node(nodeData);\r\n        }\r\n    \r\n        // Handle duplicates.\r\n        if (nodeData === currentNode.data) {\r\n            return currentNode;\r\n        } \r\n    \r\n        // Insert into the left or right subtree based on nodeData comparison.\r\n        if (nodeData < currentNode.data) {\r\n            if (currentNode.left === null) {\r\n                currentNode.left = new Node(nodeData); // Insert in left subtree.\r\n            } else {\r\n                this.insert(nodeData, currentNode.left); // Recur on left subtree.\r\n            }\r\n        } else if (nodeData > currentNode.data) {\r\n            if (currentNode.right === null) {\r\n                currentNode.right = new Node(nodeData); // Insert in right subtree.\r\n            } else {\r\n                this.insert(nodeData, currentNode.right); // Recur on right subtree.\r\n            }\r\n        }\r\n    \r\n        return currentNode;\r\n    }    \r\n    \r\n    delete(nodeData, currentNode = this.root) {\r\n        // Base case: If the node is null, return null (nodeData not found).\r\n        if (currentNode === null) return null;\r\n    \r\n        // Traverse to the correct node for deletion.\r\n        if (nodeData < currentNode.data) {\r\n            currentNode.left = this.delete(nodeData, currentNode.left);  // Recursively delete in the left subtree.\r\n        } else if (nodeData > currentNode.data) {\r\n            currentNode.right = this.delete(nodeData, currentNode.right);  // Recursively delete in the right subtree.\r\n        } \r\n    \r\n        // Node found: Handle the three deletion cases.\r\n        if (nodeData === currentNode.data) {\r\n            // Case 1: Leaf node (no children).\r\n            if (currentNode.left === null && currentNode.right === null) {\r\n                return null;\r\n            }\r\n    \r\n            // Case 2: Node with only one child.\r\n            if (currentNode.left === null) {\r\n                return currentNode.right;\r\n            }\r\n            if (currentNode.right === null) {\r\n                return currentNode.left;\r\n            }\r\n    \r\n            // Case 3: Node with two children.\r\n            let successorNode = this.getSuccessor(currentNode);\r\n            currentNode.data = successorNode.data;\r\n            currentNode.right = this.delete(successorNode.data, currentNode.right);  // Remove successor.\r\n        }\r\n    \r\n        return currentNode;  // Return the updated node to maintain the tree structure.\r\n    }\r\n    \r\n    getSuccessor(currentNode) {\r\n        let temp = currentNode.right;\r\n        while(temp !== null && temp.left !== null) {\r\n            temp = temp.left;\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    find(nodeData, currentNode = this.root) {\r\n        // Base case: If the current node is null, return null (nodeData not found).\r\n        if (currentNode === null) return null;\r\n    \r\n        // If the nodeData is found, return the current node.\r\n        if (nodeData === currentNode.data) {\r\n            return currentNode;\r\n        }\r\n    \r\n        // Traverse left or right based on the nodeData comparison.\r\n        if (nodeData < currentNode.data) {\r\n            return this.find(nodeData, currentNode.left);  // Search in the left subtree.\r\n        } else {\r\n            return this.find(nodeData, currentNode.right);  // Search in the right subtree.\r\n        }\r\n    }       \r\n\r\n    levelOrderIterative(callback) {\r\n        // Ensure function is called with a callback.\r\n        if (!callback) throw new Error(\"A callback is required to run this method!\");\r\n        if (typeof callback !== 'function') throw new Error(\"A callback provided must be a function!\");\r\n\r\n        let rootNode = this.root;\r\n        // Base case if root node is null exit traversal.\r\n        if (rootNode === null) return;\r\n\r\n        let nodeQueue = [];\r\n        nodeQueue.push(rootNode);\r\n\r\n        while(nodeQueue.length) {\r\n            // Get first node from queue, remove it, process its data via callback and enque its children.\r\n            let currentNode = nodeQueue.shift();\r\n            callback(currentNode.data);\r\n            if (currentNode.left !== null) nodeQueue.push(currentNode.left);\r\n            if (currentNode.right !== null) nodeQueue.push(currentNode.right);\r\n        }\r\n\r\n    }\r\n\r\n    levelOrderRecursive(callback) {\r\n        // Ensure function is called with a callback.\r\n        if (!callback) throw new Error(\"A callback is required to run this method!\");\r\n        if (typeof callback !== 'function') throw new Error(\"A callback provided must be a function!\");\r\n    \r\n        // Base case if root node is null exit traversal.\r\n        let currentNode = this.root;\r\n        if (currentNode === null) return;\r\n    \r\n        let levelsInTree = this._treeHeight() + 1;\r\n        let levelTraversalCounter = 0;\r\n        while (levelTraversalCounter < levelsInTree) {\r\n            this._recursiveLevelOrderTraverser(levelTraversalCounter, callback);\r\n            levelTraversalCounter++;\r\n        }\r\n    }\r\n\r\n    testCallBack(data) {\r\n        console.log(data); // logs the data of the node.\r\n    }\r\n\r\n    _recursiveLevelOrderTraverser(targetLevel, callback, currentLevel = 0, currentNode = this.root) {\r\n        // If the node is null, just return.\r\n        if (currentNode === null) return;\r\n    \r\n        // Base case: If we've reached the target level, call the callback.\r\n        if (currentLevel === targetLevel) {\r\n            callback(currentNode.data);\r\n            return;\r\n        }\r\n    \r\n        // Traverse left and right subtrees with incremented level.\r\n        this._recursiveLevelOrderTraverser(targetLevel, callback, currentLevel + 1, currentNode.left);\r\n        this._recursiveLevelOrderTraverser(targetLevel, callback, currentLevel + 1, currentNode.right);\r\n    }    \r\n\r\n    _treeHeight(currentNode = this.root) {\r\n        if (currentNode === null) return -1;  // Base case for empty node\r\n        let leftHeight = this._treeHeight(currentNode.left);\r\n        let rightHeight = this._treeHeight(currentNode.right);\r\n        return Math.max(leftHeight, rightHeight) + 1;\r\n    }\r\n\r\n    depth(nodeData, currentNode = this.root) {\r\n        // Base case if root is null, return -1.\r\n        if (currentNode === null) return -1;\r\n    \r\n        // Base case if node is found, return 0.\r\n        if (nodeData === currentNode.data) return 0;\r\n        \r\n        // Handle left and right sub-branches.\r\n        if (nodeData < currentNode.data) return 1 + this.depth(nodeData, currentNode.left);\r\n        if (nodeData > currentNode.data) return 1 + this.depth(nodeData, currentNode.right);\r\n    }    \r\n    \r\n    height(nodeData, currentNode = this.root) {\r\n        if (currentNode === null) return -1;  // Base case for empty node\r\n    \r\n        let leftHeight = this.height(nodeData, currentNode.left);\r\n        let rightHeight = this.height(nodeData, currentNode.right);\r\n    \r\n        let largestOfHeights = Math.max(leftHeight, rightHeight) + 1;\r\n    \r\n        if (nodeData === currentNode.data) return largestOfHeights;\r\n    \r\n        return Math.max(leftHeight, rightHeight);\r\n    }  \r\n\r\n    inOrder(callback) {\r\n        if (!callback) throw new Error(\"A callback is required to run this method!\");\r\n        if (typeof callback !== 'function') throw new Error(\"A callback provided must be a function!\");\r\n        this._inOrderTraverser(callback);\r\n    }\r\n\r\n    _inOrderTraverser(callback, currentNode = this.root) {\r\n        // Base case if root is null, return.\r\n        if (currentNode === null) return;\r\n\r\n        if (currentNode.left) this._inOrderTraverser(callback, currentNode.left);\r\n        callback(currentNode.data);\r\n        if (currentNode.right) this._inOrderTraverser(callback, currentNode.right);\r\n    }\r\n    \r\n    preOrder(callback) {\r\n        if (!callback) throw new Error(\"A callback is required to run this method!\");\r\n        if (typeof callback !== 'function') throw new Error(\"A callback provided must be a function!\");\r\n        this._preOrderTraverser(callback);\r\n    }\r\n\r\n    _preOrderTraverser(callback, currentNode = this.root) {\r\n        // Base case if root is null.\r\n        if (currentNode === null) return;\r\n\r\n        // Process root first.\r\n        callback(currentNode.data);\r\n\r\n        // Visit left and right subtrees\r\n        if (currentNode.left) this._preOrderTraverser(callback, currentNode.left);\r\n        if (currentNode.right) this._preOrderTraverser(callback, currentNode.right);\r\n    }\r\n\r\n    postOrder(callback) {\r\n        if (!callback) throw new Error(\"A callback is required to run this method!\");\r\n        if (typeof callback !== 'function') throw new Error(\"A callback provided must be a function!\");\r\n        this._postOrderTraverser(callback);\r\n    }\r\n\r\n    _postOrderTraverser(callback, currentNode = this.root) {\r\n        if (currentNode === null) return;\r\n        if (currentNode.left) this._postOrderTraverser(callback, currentNode.left);\r\n        if (currentNode.right) this._postOrderTraverser(callback, currentNode.right);\r\n        callback(currentNode.data);\r\n    }\r\n\r\n    isBalanced(currentNode = this.root) {\r\n        if (currentNode === null) return true; // Base case: empty node.\r\n    \r\n        let leftHeight = this._treeHeight(currentNode.left);\r\n        let rightHeight = this._treeHeight(currentNode.right);\r\n    \r\n        if (Math.abs(leftHeight - rightHeight) > 1) return false;\r\n        \r\n        // Recursively check the balance of the left and right subtrees\r\n        return this.isBalanced(currentNode.left) && this.isBalanced(currentNode.right);\r\n    }\r\n\r\n    rebalance() {\r\n        if (this.root === null || this.isBalanced()) return this.root; // return the root if already balanced or empty.\r\n        \r\n        let newArray = [];\r\n        const populateNewArray = (value) => newArray.push(value);\r\n        \r\n        // Populate newArray with an in-order traversal\r\n        this.inOrder(populateNewArray);\r\n        \r\n        // Rebuild the tree after sorting and removing duplicates\r\n        const sortedArray = this.mergeSort(this.removeDuplicate(newArray));\r\n        this.root = this.buildTree(sortedArray);\r\n        return this.root;\r\n    }    \r\n    \r\n}\r\n\r\nconst testArray = [1, 7, 4, 23, 8, 9, 4, 3, 5, 7, 9, 67, 6345, 324];\r\nconst testTree = new Tree(testArray).root;\r\n\r\nconst prettyPrint = (node, prefix = \"\", isLeft = true) => {\r\n    if (node === null) {\r\n      return;\r\n    }\r\n    if (node.right !== null) {\r\n      prettyPrint(node.right, `${prefix}${isLeft ? \"│   \" : \"    \"}`, false);\r\n    }\r\n    console.log(`${prefix}${isLeft ? \"└── \" : \"┌── \"}${node.data}`);\r\n    if (node.left !== null) {\r\n      prettyPrint(node.left, `${prefix}${isLeft ? \"    \" : \"│   \"}`, true);\r\n    }\r\n  }; \r\n\r\n// prettyPrint(testTree);\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsY0FBYztBQUNkLHlEQUF5RDtBQUN6RDtBQUNBLFVBQVU7QUFDVjtBQUNBLHdEQUF3RDtBQUN4RCxjQUFjO0FBQ2QsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSxVQUFVO0FBQ1YsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsVUFBVTtBQUNWLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLEVBQUUseUJBQXlCO0FBQ25FO0FBQ0EsbUJBQW1CLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxVQUFVO0FBQ2pFO0FBQ0EsZ0NBQWdDLE9BQU8sRUFBRSx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RldnN0YXJ0YnVpbGRpbmcvLi9zcmMvYXBwLmpzPzExMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT2JqZWN0IE9yaWVudGVkIGFwcHJvYWNoIHRvIGJ1aWxkIGEgYmFsYW5hY2VkIEJpbmFyeSBTZWFyY2ggVHJlZS5cclxuXHJcbmNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSl7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFycmF5KSB7XHJcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMubWVyZ2VTb3J0KHRoaXMucmVtb3ZlRHVwbGljYXRlKGFycmF5KSk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5idWlsZFRyZWUodGhpcy5hcnJheSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlRHVwbGljYXRlKGFycmF5KSB7XHJcbiAgICAgICAgLy8gRXhpdCBpZiB0aGlzIGlzIG5vdCBhbiBhcnJheS5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSByZXR1cm47XHJcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XHJcbiAgICB9XHJcblxyXG4gICAgbWVyZ2VTb3J0KGFycmF5LCBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIGlmIChsb3cgPCBoaWdoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIG1pZGRsZSBwb2ludC5cclxuICAgICAgICAgICAgbGV0IG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlIHNvcnQgYm90aCBoYWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VTb3J0KGFycmF5LCBsb3csIG1pZGRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VTb3J0KGFycmF5LCBtaWRkbGUgKyAxLCBoaWdoKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgY29waWVzIG9mIHRoZSBzdWJhcnJheXNcclxuICAgICAgICAgICAgbGV0IGxlZnRBcnJheSA9IGFycmF5LnNsaWNlKGxvdywgbWlkZGxlICsgMSk7XHJcbiAgICAgICAgICAgIGxldCByaWdodEFycmF5ID0gYXJyYXkuc2xpY2UobWlkZGxlICsgMSwgaGlnaCArIDEpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBhcnJheXNcclxuICAgICAgICAgICAgbGV0IGkgPSAwLCBqID0gMCwgayA9IGxvdztcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZWZ0QXJyYXkubGVuZ3RoICYmIGogPCByaWdodEFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRBcnJheVtpXSA8PSByaWdodEFycmF5W2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaysrXSA9IGxlZnRBcnJheVtpKytdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVtrKytdID0gcmlnaHRBcnJheVtqKytdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gQ29weSByZW1haW5pbmcgZWxlbWVudHMgb2YgbGVmdEFycmF5LCBpZiBhbnlcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZWZ0QXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtrKytdID0gbGVmdEFycmF5W2krK107XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgLy8gQ29weSByZW1haW5pbmcgZWxlbWVudHMgb2YgcmlnaHRBcnJheSwgaWYgYW55XHJcbiAgICAgICAgICAgIHdoaWxlIChqIDwgcmlnaHRBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2srK10gPSByaWdodEFycmF5W2orK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRUcmVlKGFycmF5LCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBGaW5kIG1pZGRsZSBlbGVtZW50LlxyXG4gICAgICAgIGxldCBtaWQgPSBzdGFydCArIE1hdGguZmxvb3IoKGVuZCAtIHN0YXJ0KSAvIDIpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcm9vdCBub2RlXHJcbiAgICAgICAgbGV0IHJvb3QgPSBuZXcgTm9kZShhcnJheVttaWRdKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzLlxyXG4gICAgICAgIHJvb3QubGVmdCA9IHRoaXMuYnVpbGRUcmVlKGFycmF5LCBzdGFydCwgbWlkIC0gMSk7XHJcbiAgICAgICAgcm9vdC5yaWdodCA9IHRoaXMuYnVpbGRUcmVlKGFycmF5LCBtaWQgKyAxLCBlbmQpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnQobm9kZURhdGEsIGN1cnJlbnROb2RlID0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgcm9vdCB3aXRoIGEgbmV3IG5vZGUuXHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTm9kZShub2RlRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gSWYgY3VycmVudE5vZGUgaXMgbnVsbCwgcmV0dXJuIGEgbmV3IG5vZGUgKHNob3VsZCBub3QgaGFwcGVuIGluIHR5cGljYWwgdXNhZ2UpLlxyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGUobm9kZURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBkdXBsaWNhdGVzLlxyXG4gICAgICAgIGlmIChub2RlRGF0YSA9PT0gY3VycmVudE5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XHJcbiAgICAgICAgfSBcclxuICAgIFxyXG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBsZWZ0IG9yIHJpZ2h0IHN1YnRyZWUgYmFzZWQgb24gbm9kZURhdGEgY29tcGFyaXNvbi5cclxuICAgICAgICBpZiAobm9kZURhdGEgPCBjdXJyZW50Tm9kZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0ID0gbmV3IE5vZGUobm9kZURhdGEpOyAvLyBJbnNlcnQgaW4gbGVmdCBzdWJ0cmVlLlxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQobm9kZURhdGEsIGN1cnJlbnROb2RlLmxlZnQpOyAvLyBSZWN1ciBvbiBsZWZ0IHN1YnRyZWUuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVEYXRhID4gY3VycmVudE5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0ID0gbmV3IE5vZGUobm9kZURhdGEpOyAvLyBJbnNlcnQgaW4gcmlnaHQgc3VidHJlZS5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KG5vZGVEYXRhLCBjdXJyZW50Tm9kZS5yaWdodCk7IC8vIFJlY3VyIG9uIHJpZ2h0IHN1YnRyZWUuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XHJcbiAgICB9ICAgIFxyXG4gICAgXHJcbiAgICBkZWxldGUobm9kZURhdGEsIGN1cnJlbnROb2RlID0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgLy8gQmFzZSBjYXNlOiBJZiB0aGUgbm9kZSBpcyBudWxsLCByZXR1cm4gbnVsbCAobm9kZURhdGEgbm90IGZvdW5kKS5cclxuICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIGNvcnJlY3Qgbm9kZSBmb3IgZGVsZXRpb24uXHJcbiAgICAgICAgaWYgKG5vZGVEYXRhIDwgY3VycmVudE5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0ID0gdGhpcy5kZWxldGUobm9kZURhdGEsIGN1cnJlbnROb2RlLmxlZnQpOyAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGluIHRoZSBsZWZ0IHN1YnRyZWUuXHJcbiAgICAgICAgfSBlbHNlIGlmIChub2RlRGF0YSA+IGN1cnJlbnROb2RlLmRhdGEpIHtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHQgPSB0aGlzLmRlbGV0ZShub2RlRGF0YSwgY3VycmVudE5vZGUucmlnaHQpOyAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGluIHRoZSByaWdodCBzdWJ0cmVlLlxyXG4gICAgICAgIH0gXHJcbiAgICBcclxuICAgICAgICAvLyBOb2RlIGZvdW5kOiBIYW5kbGUgdGhlIHRocmVlIGRlbGV0aW9uIGNhc2VzLlxyXG4gICAgICAgIGlmIChub2RlRGF0YSA9PT0gY3VycmVudE5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBDYXNlIDE6IExlYWYgbm9kZSAobm8gY2hpbGRyZW4pLlxyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubGVmdCA9PT0gbnVsbCAmJiBjdXJyZW50Tm9kZS5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAvLyBDYXNlIDI6IE5vZGUgd2l0aCBvbmx5IG9uZSBjaGlsZC5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gQ2FzZSAzOiBOb2RlIHdpdGggdHdvIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBsZXQgc3VjY2Vzc29yTm9kZSA9IHRoaXMuZ2V0U3VjY2Vzc29yKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUuZGF0YSA9IHN1Y2Nlc3Nvck5vZGUuZGF0YTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHQgPSB0aGlzLmRlbGV0ZShzdWNjZXNzb3JOb2RlLmRhdGEsIGN1cnJlbnROb2RlLnJpZ2h0KTsgIC8vIFJlbW92ZSBzdWNjZXNzb3IuXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlOyAgLy8gUmV0dXJuIHRoZSB1cGRhdGVkIG5vZGUgdG8gbWFpbnRhaW4gdGhlIHRyZWUgc3RydWN0dXJlLlxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXRTdWNjZXNzb3IoY3VycmVudE5vZGUpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IGN1cnJlbnROb2RlLnJpZ2h0O1xyXG4gICAgICAgIHdoaWxlKHRlbXAgIT09IG51bGwgJiYgdGVtcC5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmQobm9kZURhdGEsIGN1cnJlbnROb2RlID0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgLy8gQmFzZSBjYXNlOiBJZiB0aGUgY3VycmVudCBub2RlIGlzIG51bGwsIHJldHVybiBudWxsIChub2RlRGF0YSBub3QgZm91bmQpLlxyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgICAgICAvLyBJZiB0aGUgbm9kZURhdGEgaXMgZm91bmQsIHJldHVybiB0aGUgY3VycmVudCBub2RlLlxyXG4gICAgICAgIGlmIChub2RlRGF0YSA9PT0gY3VycmVudE5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gVHJhdmVyc2UgbGVmdCBvciByaWdodCBiYXNlZCBvbiB0aGUgbm9kZURhdGEgY29tcGFyaXNvbi5cclxuICAgICAgICBpZiAobm9kZURhdGEgPCBjdXJyZW50Tm9kZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmQobm9kZURhdGEsIGN1cnJlbnROb2RlLmxlZnQpOyAgLy8gU2VhcmNoIGluIHRoZSBsZWZ0IHN1YnRyZWUuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZChub2RlRGF0YSwgY3VycmVudE5vZGUucmlnaHQpOyAgLy8gU2VhcmNoIGluIHRoZSByaWdodCBzdWJ0cmVlLlxyXG4gICAgICAgIH1cclxuICAgIH0gICAgICAgXHJcblxyXG4gICAgbGV2ZWxPcmRlckl0ZXJhdGl2ZShjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIEVuc3VyZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIGNhbGxiYWNrLlxyXG4gICAgICAgIGlmICghY2FsbGJhY2spIHRocm93IG5ldyBFcnJvcihcIkEgY2FsbGJhY2sgaXMgcmVxdWlyZWQgdG8gcnVuIHRoaXMgbWV0aG9kIVwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJBIGNhbGxiYWNrIHByb3ZpZGVkIG11c3QgYmUgYSBmdW5jdGlvbiFcIik7XHJcblxyXG4gICAgICAgIGxldCByb290Tm9kZSA9IHRoaXMucm9vdDtcclxuICAgICAgICAvLyBCYXNlIGNhc2UgaWYgcm9vdCBub2RlIGlzIG51bGwgZXhpdCB0cmF2ZXJzYWwuXHJcbiAgICAgICAgaWYgKHJvb3ROb2RlID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBub2RlUXVldWUgPSBbXTtcclxuICAgICAgICBub2RlUXVldWUucHVzaChyb290Tm9kZSk7XHJcblxyXG4gICAgICAgIHdoaWxlKG5vZGVRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGZpcnN0IG5vZGUgZnJvbSBxdWV1ZSwgcmVtb3ZlIGl0LCBwcm9jZXNzIGl0cyBkYXRhIHZpYSBjYWxsYmFjayBhbmQgZW5xdWUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlUXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgY2FsbGJhY2soY3VycmVudE5vZGUuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0ICE9PSBudWxsKSBub2RlUXVldWUucHVzaChjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJpZ2h0ICE9PSBudWxsKSBub2RlUXVldWUucHVzaChjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBsZXZlbE9yZGVyUmVjdXJzaXZlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGEgY2FsbGJhY2suXHJcbiAgICAgICAgaWYgKCFjYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKFwiQSBjYWxsYmFjayBpcyByZXF1aXJlZCB0byBydW4gdGhpcyBtZXRob2QhXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcIkEgY2FsbGJhY2sgcHJvdmlkZWQgbXVzdCBiZSBhIGZ1bmN0aW9uIVwiKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEJhc2UgY2FzZSBpZiByb290IG5vZGUgaXMgbnVsbCBleGl0IHRyYXZlcnNhbC5cclxuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBudWxsKSByZXR1cm47XHJcbiAgICBcclxuICAgICAgICBsZXQgbGV2ZWxzSW5UcmVlID0gdGhpcy5fdHJlZUhlaWdodCgpICsgMTtcclxuICAgICAgICBsZXQgbGV2ZWxUcmF2ZXJzYWxDb3VudGVyID0gMDtcclxuICAgICAgICB3aGlsZSAobGV2ZWxUcmF2ZXJzYWxDb3VudGVyIDwgbGV2ZWxzSW5UcmVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZUxldmVsT3JkZXJUcmF2ZXJzZXIobGV2ZWxUcmF2ZXJzYWxDb3VudGVyLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGxldmVsVHJhdmVyc2FsQ291bnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0ZXN0Q2FsbEJhY2soZGF0YSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpOyAvLyBsb2dzIHRoZSBkYXRhIG9mIHRoZSBub2RlLlxyXG4gICAgfVxyXG5cclxuICAgIF9yZWN1cnNpdmVMZXZlbE9yZGVyVHJhdmVyc2VyKHRhcmdldExldmVsLCBjYWxsYmFjaywgY3VycmVudExldmVsID0gMCwgY3VycmVudE5vZGUgPSB0aGlzLnJvb3QpIHtcclxuICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyBudWxsLCBqdXN0IHJldHVybi5cclxuICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IG51bGwpIHJldHVybjtcclxuICAgIFxyXG4gICAgICAgIC8vIEJhc2UgY2FzZTogSWYgd2UndmUgcmVhY2hlZCB0aGUgdGFyZ2V0IGxldmVsLCBjYWxsIHRoZSBjYWxsYmFjay5cclxuICAgICAgICBpZiAoY3VycmVudExldmVsID09PSB0YXJnZXRMZXZlbCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhjdXJyZW50Tm9kZS5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIFRyYXZlcnNlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzIHdpdGggaW5jcmVtZW50ZWQgbGV2ZWwuXHJcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlTGV2ZWxPcmRlclRyYXZlcnNlcih0YXJnZXRMZXZlbCwgY2FsbGJhY2ssIGN1cnJlbnRMZXZlbCArIDEsIGN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZUxldmVsT3JkZXJUcmF2ZXJzZXIodGFyZ2V0TGV2ZWwsIGNhbGxiYWNrLCBjdXJyZW50TGV2ZWwgKyAxLCBjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIF90cmVlSGVpZ2h0KGN1cnJlbnROb2RlID0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBudWxsKSByZXR1cm4gLTE7ICAvLyBCYXNlIGNhc2UgZm9yIGVtcHR5IG5vZGVcclxuICAgICAgICBsZXQgbGVmdEhlaWdodCA9IHRoaXMuX3RyZWVIZWlnaHQoY3VycmVudE5vZGUubGVmdCk7XHJcbiAgICAgICAgbGV0IHJpZ2h0SGVpZ2h0ID0gdGhpcy5fdHJlZUhlaWdodChjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxlZnRIZWlnaHQsIHJpZ2h0SGVpZ2h0KSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZGVwdGgobm9kZURhdGEsIGN1cnJlbnROb2RlID0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgLy8gQmFzZSBjYXNlIGlmIHJvb3QgaXMgbnVsbCwgcmV0dXJuIC0xLlxyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIC0xO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQmFzZSBjYXNlIGlmIG5vZGUgaXMgZm91bmQsIHJldHVybiAwLlxyXG4gICAgICAgIGlmIChub2RlRGF0YSA9PT0gY3VycmVudE5vZGUuZGF0YSkgcmV0dXJuIDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSGFuZGxlIGxlZnQgYW5kIHJpZ2h0IHN1Yi1icmFuY2hlcy5cclxuICAgICAgICBpZiAobm9kZURhdGEgPCBjdXJyZW50Tm9kZS5kYXRhKSByZXR1cm4gMSArIHRoaXMuZGVwdGgobm9kZURhdGEsIGN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIGlmIChub2RlRGF0YSA+IGN1cnJlbnROb2RlLmRhdGEpIHJldHVybiAxICsgdGhpcy5kZXB0aChub2RlRGF0YSwgY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgfSAgICBcclxuICAgIFxyXG4gICAgaGVpZ2h0KG5vZGVEYXRhLCBjdXJyZW50Tm9kZSA9IHRoaXMucm9vdCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIC0xOyAgLy8gQmFzZSBjYXNlIGZvciBlbXB0eSBub2RlXHJcbiAgICBcclxuICAgICAgICBsZXQgbGVmdEhlaWdodCA9IHRoaXMuaGVpZ2h0KG5vZGVEYXRhLCBjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICBsZXQgcmlnaHRIZWlnaHQgPSB0aGlzLmhlaWdodChub2RlRGF0YSwgY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgXHJcbiAgICAgICAgbGV0IGxhcmdlc3RPZkhlaWdodHMgPSBNYXRoLm1heChsZWZ0SGVpZ2h0LCByaWdodEhlaWdodCkgKyAxO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKG5vZGVEYXRhID09PSBjdXJyZW50Tm9kZS5kYXRhKSByZXR1cm4gbGFyZ2VzdE9mSGVpZ2h0cztcclxuICAgIFxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChsZWZ0SGVpZ2h0LCByaWdodEhlaWdodCk7XHJcbiAgICB9ICBcclxuXHJcbiAgICBpbk9yZGVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKFwiQSBjYWxsYmFjayBpcyByZXF1aXJlZCB0byBydW4gdGhpcyBtZXRob2QhXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcIkEgY2FsbGJhY2sgcHJvdmlkZWQgbXVzdCBiZSBhIGZ1bmN0aW9uIVwiKTtcclxuICAgICAgICB0aGlzLl9pbk9yZGVyVHJhdmVyc2VyKGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBfaW5PcmRlclRyYXZlcnNlcihjYWxsYmFjaywgY3VycmVudE5vZGUgPSB0aGlzLnJvb3QpIHtcclxuICAgICAgICAvLyBCYXNlIGNhc2UgaWYgcm9vdCBpcyBudWxsLCByZXR1cm4uXHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KSB0aGlzLl9pbk9yZGVyVHJhdmVyc2VyKGNhbGxiYWNrLCBjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICBjYWxsYmFjayhjdXJyZW50Tm9kZS5kYXRhKTtcclxuICAgICAgICBpZiAoY3VycmVudE5vZGUucmlnaHQpIHRoaXMuX2luT3JkZXJUcmF2ZXJzZXIoY2FsbGJhY2ssIGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJlT3JkZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB0aHJvdyBuZXcgRXJyb3IoXCJBIGNhbGxiYWNrIGlzIHJlcXVpcmVkIHRvIHJ1biB0aGlzIG1ldGhvZCFcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiQSBjYWxsYmFjayBwcm92aWRlZCBtdXN0IGJlIGEgZnVuY3Rpb24hXCIpO1xyXG4gICAgICAgIHRoaXMuX3ByZU9yZGVyVHJhdmVyc2VyKGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBfcHJlT3JkZXJUcmF2ZXJzZXIoY2FsbGJhY2ssIGN1cnJlbnROb2RlID0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgLy8gQmFzZSBjYXNlIGlmIHJvb3QgaXMgbnVsbC5cclxuICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gUHJvY2VzcyByb290IGZpcnN0LlxyXG4gICAgICAgIGNhbGxiYWNrKGN1cnJlbnROb2RlLmRhdGEpO1xyXG5cclxuICAgICAgICAvLyBWaXNpdCBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KSB0aGlzLl9wcmVPcmRlclRyYXZlcnNlcihjYWxsYmFjaywgY3VycmVudE5vZGUubGVmdCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJpZ2h0KSB0aGlzLl9wcmVPcmRlclRyYXZlcnNlcihjYWxsYmFjaywgY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHBvc3RPcmRlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2spIHRocm93IG5ldyBFcnJvcihcIkEgY2FsbGJhY2sgaXMgcmVxdWlyZWQgdG8gcnVuIHRoaXMgbWV0aG9kIVwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJBIGNhbGxiYWNrIHByb3ZpZGVkIG11c3QgYmUgYSBmdW5jdGlvbiFcIik7XHJcbiAgICAgICAgdGhpcy5fcG9zdE9yZGVyVHJhdmVyc2VyKGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBfcG9zdE9yZGVyVHJhdmVyc2VyKGNhbGxiYWNrLCBjdXJyZW50Tm9kZSA9IHRoaXMucm9vdCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KSB0aGlzLl9wb3N0T3JkZXJUcmF2ZXJzZXIoY2FsbGJhY2ssIGN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodCkgdGhpcy5fcG9zdE9yZGVyVHJhdmVyc2VyKGNhbGxiYWNrLCBjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgY2FsbGJhY2soY3VycmVudE5vZGUuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNCYWxhbmNlZChjdXJyZW50Tm9kZSA9IHRoaXMucm9vdCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7IC8vIEJhc2UgY2FzZTogZW1wdHkgbm9kZS5cclxuICAgIFxyXG4gICAgICAgIGxldCBsZWZ0SGVpZ2h0ID0gdGhpcy5fdHJlZUhlaWdodChjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICBsZXQgcmlnaHRIZWlnaHQgPSB0aGlzLl90cmVlSGVpZ2h0KGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgIFxyXG4gICAgICAgIGlmIChNYXRoLmFicyhsZWZ0SGVpZ2h0IC0gcmlnaHRIZWlnaHQpID4gMSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIHRoZSBiYWxhbmNlIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzQmFsYW5jZWQoY3VycmVudE5vZGUubGVmdCkgJiYgdGhpcy5pc0JhbGFuY2VkKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICByZWJhbGFuY2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCB8fCB0aGlzLmlzQmFsYW5jZWQoKSkgcmV0dXJuIHRoaXMucm9vdDsgLy8gcmV0dXJuIHRoZSByb290IGlmIGFscmVhZHkgYmFsYW5jZWQgb3IgZW1wdHkuXHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG5ld0FycmF5ID0gW107XHJcbiAgICAgICAgY29uc3QgcG9wdWxhdGVOZXdBcnJheSA9ICh2YWx1ZSkgPT4gbmV3QXJyYXkucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUG9wdWxhdGUgbmV3QXJyYXkgd2l0aCBhbiBpbi1vcmRlciB0cmF2ZXJzYWxcclxuICAgICAgICB0aGlzLmluT3JkZXIocG9wdWxhdGVOZXdBcnJheSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVidWlsZCB0aGUgdHJlZSBhZnRlciBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXHJcbiAgICAgICAgY29uc3Qgc29ydGVkQXJyYXkgPSB0aGlzLm1lcmdlU29ydCh0aGlzLnJlbW92ZUR1cGxpY2F0ZShuZXdBcnJheSkpO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuYnVpbGRUcmVlKHNvcnRlZEFycmF5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xyXG4gICAgfSAgICBcclxuICAgIFxyXG59XHJcblxyXG5jb25zdCB0ZXN0QXJyYXkgPSBbMSwgNywgNCwgMjMsIDgsIDksIDQsIDMsIDUsIDcsIDksIDY3LCA2MzQ1LCAzMjRdO1xyXG5jb25zdCB0ZXN0VHJlZSA9IG5ldyBUcmVlKHRlc3RBcnJheSkucm9vdDtcclxuXHJcbmNvbnN0IHByZXR0eVByaW50ID0gKG5vZGUsIHByZWZpeCA9IFwiXCIsIGlzTGVmdCA9IHRydWUpID0+IHtcclxuICAgIGlmIChub2RlID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgIHByZXR0eVByaW50KG5vZGUucmlnaHQsIGAke3ByZWZpeH0ke2lzTGVmdCA/IFwi4pSCICAgXCIgOiBcIiAgICBcIn1gLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhgJHtwcmVmaXh9JHtpc0xlZnQgPyBcIuKUlOKUgOKUgCBcIiA6IFwi4pSM4pSA4pSAIFwifSR7bm9kZS5kYXRhfWApO1xyXG4gICAgaWYgKG5vZGUubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICBwcmV0dHlQcmludChub2RlLmxlZnQsIGAke3ByZWZpeH0ke2lzTGVmdCA/IFwiICAgIFwiIDogXCLilIIgICBcIn1gLCB0cnVlKTtcclxuICAgIH1cclxuICB9OyBcclxuXHJcbi8vIHByZXR0eVByaW50KHRlc3RUcmVlKTtcclxuXHJcbmV4cG9ydCB7IFRyZWUsIHByZXR0eVByaW50IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/app.js\");\n\r\n\r\nfunction randomNumArray(min, max) {\r\n    let numbersCount = 15; // You can adjust the number of elements\r\n    let array = [];\r\n    for (let counter = 0; counter < numbersCount; counter++) {\r\n        // Generating random integers between min and max\r\n        array.push(Math.floor(Math.random() * (max - min + 1)) + min);\r\n    }\r\n    return array;\r\n}\r\n\r\nconst randomNumbers = randomNumArray(0, 100);\r\nconsole.log(randomNumbers);\r\nconst testTree = new _app__WEBPACK_IMPORTED_MODULE_0__.Tree(randomNumbers);\r\n(0,_app__WEBPACK_IMPORTED_MODULE_0__.prettyPrint)(testTree.root);\r\nconsole.log(testTree.isBalanced());\r\n// console.log(\"Iterative Level Order Traversal\");\r\n// testTree.levelOrderIterative(console.log);\r\n// console.log(\"Recursive level order traversal\");\r\n// testTree.levelOrderRecursive(console.log);\r\n// console.log(\"Preorder traversal\");\r\n// testTree.preOrder(console.log);\r\n// console.log(\"Post order traversal\");\r\n// testTree.postOrder(console.log);\r\n// console.log(\"In Order Traversal\");\r\n// testTree.inOrder(console.log);\r\nlet newRandomNumbers = randomNumArray(100, 200);\r\nnewRandomNumbers.forEach(number => testTree.insert(number));\r\nconsole.log(testTree.isBalanced());\r\ntestTree.rebalance();\r\nconsole.log(testTree.isBalanced());\r\n(0,_app__WEBPACK_IMPORTED_MODULE_0__.prettyPrint)(testTree.root);\r\n// console.log(\"Iterative Level Order Traversal\");\r\n// testTree.levelOrderIterative(console.log);\r\n// console.log(\"Preorder traversal\");\r\n// testTree.preOrder(console.log);\r\n// console.log(\"Post order traversal\");\r\n// testTree.postOrder(console.log);\r\n// console.log(\"In Order Traversal\");\r\n// testTree.inOrder(console.log);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBMEM7QUFDMUM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBSTtBQUN6QixpREFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGV2c3RhcnRidWlsZGluZy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyZWUsIHByZXR0eVByaW50IH0gZnJvbSBcIi4vYXBwXCI7XHJcblxyXG5mdW5jdGlvbiByYW5kb21OdW1BcnJheShtaW4sIG1heCkge1xyXG4gICAgbGV0IG51bWJlcnNDb3VudCA9IDE1OyAvLyBZb3UgY2FuIGFkanVzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXHJcbiAgICBsZXQgYXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGNvdW50ZXIgPSAwOyBjb3VudGVyIDwgbnVtYmVyc0NvdW50OyBjb3VudGVyKyspIHtcclxuICAgICAgICAvLyBHZW5lcmF0aW5nIHJhbmRvbSBpbnRlZ2VycyBiZXR3ZWVuIG1pbiBhbmQgbWF4XHJcbiAgICAgICAgYXJyYXkucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxyXG5cclxuY29uc3QgcmFuZG9tTnVtYmVycyA9IHJhbmRvbU51bUFycmF5KDAsIDEwMCk7XHJcbmNvbnNvbGUubG9nKHJhbmRvbU51bWJlcnMpO1xyXG5jb25zdCB0ZXN0VHJlZSA9IG5ldyBUcmVlKHJhbmRvbU51bWJlcnMpO1xyXG5wcmV0dHlQcmludCh0ZXN0VHJlZS5yb290KTtcclxuY29uc29sZS5sb2codGVzdFRyZWUuaXNCYWxhbmNlZCgpKTtcclxuLy8gY29uc29sZS5sb2coXCJJdGVyYXRpdmUgTGV2ZWwgT3JkZXIgVHJhdmVyc2FsXCIpO1xyXG4vLyB0ZXN0VHJlZS5sZXZlbE9yZGVySXRlcmF0aXZlKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJSZWN1cnNpdmUgbGV2ZWwgb3JkZXIgdHJhdmVyc2FsXCIpO1xyXG4vLyB0ZXN0VHJlZS5sZXZlbE9yZGVyUmVjdXJzaXZlKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJQcmVvcmRlciB0cmF2ZXJzYWxcIik7XHJcbi8vIHRlc3RUcmVlLnByZU9yZGVyKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJQb3N0IG9yZGVyIHRyYXZlcnNhbFwiKTtcclxuLy8gdGVzdFRyZWUucG9zdE9yZGVyKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJJbiBPcmRlciBUcmF2ZXJzYWxcIik7XHJcbi8vIHRlc3RUcmVlLmluT3JkZXIoY29uc29sZS5sb2cpO1xyXG5sZXQgbmV3UmFuZG9tTnVtYmVycyA9IHJhbmRvbU51bUFycmF5KDEwMCwgMjAwKTtcclxubmV3UmFuZG9tTnVtYmVycy5mb3JFYWNoKG51bWJlciA9PiB0ZXN0VHJlZS5pbnNlcnQobnVtYmVyKSk7XHJcbmNvbnNvbGUubG9nKHRlc3RUcmVlLmlzQmFsYW5jZWQoKSk7XHJcbnRlc3RUcmVlLnJlYmFsYW5jZSgpO1xyXG5jb25zb2xlLmxvZyh0ZXN0VHJlZS5pc0JhbGFuY2VkKCkpO1xyXG5wcmV0dHlQcmludCh0ZXN0VHJlZS5yb290KTtcclxuLy8gY29uc29sZS5sb2coXCJJdGVyYXRpdmUgTGV2ZWwgT3JkZXIgVHJhdmVyc2FsXCIpO1xyXG4vLyB0ZXN0VHJlZS5sZXZlbE9yZGVySXRlcmF0aXZlKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJQcmVvcmRlciB0cmF2ZXJzYWxcIik7XHJcbi8vIHRlc3RUcmVlLnByZU9yZGVyKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJQb3N0IG9yZGVyIHRyYXZlcnNhbFwiKTtcclxuLy8gdGVzdFRyZWUucG9zdE9yZGVyKGNvbnNvbGUubG9nKTtcclxuLy8gY29uc29sZS5sb2coXCJJbiBPcmRlciBUcmF2ZXJzYWxcIik7XHJcbi8vIHRlc3RUcmVlLmluT3JkZXIoY29uc29sZS5sb2cpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;